import os
import typing
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from ipaddress import IPv4Address, IPv6Address
from typing import Literal, Optional, Type
from uuid import UUID

from rest_framework import serializers

from core.abstracts.serializers import ModelSerializerBase, SerializerBase

DRF_FIELD_TYPES = {
    serializers.IntegerField: "number",
    serializers.BooleanField: "boolean",
    serializers.CharField: "string",
    serializers.DateField: "string",
    serializers.DateTimeField: "string",
    serializers.DecimalField: "number",
    serializers.DurationField: "string",
    serializers.EmailField: "string",
    serializers.ModelField: "any",
    serializers.FileField: "string",
    serializers.FloatField: "number",
    serializers.ImageField: "string",
    serializers.SlugField: "any",
    serializers.TimeField: "string",
    serializers.URLField: "string",
    serializers.UUIDField: "string",
    serializers.IPAddressField: "string",
    serializers.FilePathField: "string",
    serializers.PrimaryKeyRelatedField: "number",
}

PYTHON_TYPES = {
    str: "string",
    float: "number",
    bool: "boolean",
    bytes: "any",
    int: "number",
    UUID: "string",
    Decimal: "number",
    datetime: "string",
    date: "string",
    time: "string",
    timedelta: "string",
    IPv4Address: "string",
    IPv6Address: "string",
    dict: "any",
    typing.Any: "any",
    None: "unknown",
}

FILE_DOC_TPL = """/**
 * Club Portal Type Definitions
 * Generated by club-portal-backend on %s.
 */
"""

INTERFACE_TPL = """
/**
 * %(doc)s
 */
declare interface I%(model)s {
"""

CREATE_INTERFACE_TPL = """
/**
 * Fields needed to create %(article)s %(model)s object.
 *
 * @see {@link I%(model)s}
 */
declare interface I%(model)sCreate {
"""

UPDATE_INTERFACE_TPL = """
/**
 * Fields that can be updated for %(article)s %(model)s object.
 *
 * @see {@link I%(model)s}
 */
declare interface I%(model)sUpdate {
"""

FIELD_TPL = "  %(property)s: %(type)s;\n"
OPTIONAL_FIELD_TPL = "  %(property)s?: %(type)s;\n"
READONLY_FIELD_TPL = "  readonly %(property)s: %(type)s;\n"

FIELD_DOC_TPL = "  /** %s */\n"


class TypeGenerator:
    """Create TypeScript interfaces from a list of serializers."""

    def __init__(self, serializer_classes: list[Type[ModelSerializerBase]]):

        self.types_doc = ""
        self.serializer_classes = serializer_classes

    def _get_model_article(self, model_name: str):
        """Get a/an depending on a model's name."""

        return (
            "an"
            if model_name.lower().startswith(
                (
                    "a",
                    "e",
                    "i",
                    "o",
                )
            )
            else "a"
        )

    def _get_field_type(self, field, is_list=False):
        """Return TS type for given field."""

        field_type = DRF_FIELD_TYPES.get(type(field), None) or "any"

        if is_list:
            field_type += "[]"

        return field_type

    def _get_indent(self, indent_level: int):
        return "  " * indent_level

    def _generate_prop(
        self,
        tpl: str,
        property: str,
        prop_type: str,
        doc: Optional[str] = None,
        indent_level=0,
    ):
        """Generate a TS field depending on tpl value."""

        generated = ""
        indent = self._get_indent(indent_level)
        # generated += "\n"

        if doc:
            generated += indent + FIELD_DOC_TPL % (doc,)

        generated += indent + tpl % {
            "property": property,
            "type": prop_type,
        }

        return generated

    def _generate_required_prop(self, property: str, prop_type: str, **kwargs):
        """Generate a required TS field."""
        return self._generate_prop(FIELD_TPL, property, prop_type, **kwargs)

    def _generate_optional_prop(self, property: str, prop_type: str, **kwargs):
        """Generate a optional TS field."""
        return self._generate_prop(OPTIONAL_FIELD_TPL, property, prop_type, **kwargs)

    def _generate_readonly_prop(self, property: str, prop_type: str, **kwargs):
        """Generate a readonly TS field."""
        return self._generate_prop(READONLY_FIELD_TPL, property, prop_type, **kwargs)

    def _props_factory(
        self,
        all_fields: dict[str | serializers.Field],
        ignore_nonnull: bool,
        force_optional: bool,
        indent_level=0,
    ):
        """Create function for generating props."""

        def gen_prop(prop_name, prop_type=None, required=True, readonly=False):
            field = all_fields[prop_name]
            kwargs = {
                "property": prop_name,
                "prop_type": prop_type or self._get_field_type(field),
                "doc": getattr(field, "help_text", None),
                "indent_level": indent_level,
            }

            if (
                not readonly
                and not ignore_nonnull
                and not getattr(field, "allow_null", True)
            ):
                field_prop = self._generate_required_prop(**kwargs)
            elif not readonly and (force_optional or not required):
                field_prop = self._generate_optional_prop(**kwargs)
            elif not readonly:
                field_prop = self._generate_required_prop(**kwargs)
            else:
                field_prop = self._generate_readonly_prop(**kwargs)

            return field_prop

        return gen_prop

    def _generate_props(
        self,
        serializer: SerializerBase,
        mode: Literal["read", "create", "update"],
        indent_level=0,
    ):
        """Generate a list of fields for given serializer."""

        all_fields = serializer.get_fields()
        properties = []
        indent = self._get_indent(indent_level)
        ignore_fields = []

        # Flags
        force_optional = False
        ignore_nonnull = False

        match mode:
            case "read":
                ignore_fields += serializer.writeonly_fields
            case "create":
                ignore_nonnull = True
                ignore_fields += serializer.readonly_fields
            case "update":
                ignore_nonnull = True
                force_optional = True
                ignore_fields += serializer.readonly_fields

        if hasattr(serializer, "pk_field"):
            ignore_fields.append(serializer.pk_field)

        gen_prop = self._props_factory(
            all_fields,
            ignore_nonnull=ignore_nonnull,
            indent_level=indent_level,
            force_optional=force_optional,
        )

        # Generate required fields
        for field_name in serializer.required_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field_prop = gen_prop(field_name, required=True)
            properties.append(field_prop)

        # Generate optional fields
        for field_name in serializer.optional_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field_prop = gen_prop(field_name, required=False)
            properties.append(field_prop)

        # Generate single value list fields
        for field_name in serializer.simple_list_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ManyRelatedField):
                field_type = self._get_field_type(field.child_relation, is_list=True)
            elif getattr(field, "child", None) is not None:
                field_type = self._get_field_type(field.child, is_list=True)
            else:
                field_type = "string[]"

            field_prop = gen_prop(
                field_name,
                prop_type=field_type,
                required=(field_name in serializer.required_fields),
            )
            properties.append(field_prop)

        # Generate nested fields
        for field_name in serializer.nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            nested_properties = self._generate_props(
                field,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + "  %s: {\n" % (field_name,))
            else:
                properties.append(indent + "  %s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + "  }\n")

        # Generate nested list fields
        for field_name in serializer.many_nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]
            nested_properties = self._generate_props(
                field.child,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + "  %s: {\n" % (field_name,))
            else:
                properties.append(indent + "  %s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + "  }[]\n")

        # Generate read only fields
        for field_name in serializer.readonly_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ReadOnlyField):
                # If the field is of type ReadOnly, then need to get the
                # type directly from the model (if possible)

                try:
                    model_field = getattr(
                        serializer.model_class, field.source or field_name
                    )
                    field_type_class = model_field.fget.__annotations__.get(
                        "return", "any"
                    )
                    field_type = PYTHON_TYPES.get(field_type_class, "any")
                    field_prop = gen_prop(
                        field_name, prop_type=field_type, readonly=True
                    )
                except Exception as e:
                    field_type = "unknown"
                    field_prop = gen_prop(field_name, readonly=True)
                    print(e)
            else:
                field_prop = gen_prop(field_name, readonly=True)

            properties.append(field_prop)

        return properties

    def generate_docs(self, filepath: str):
        """Convert serializers to typescript interfaces."""

        self.types_doc += FILE_DOC_TPL % datetime.now()

        for serializer_class in self.serializer_classes:
            serializer = serializer_class()
            # interface_name = serializer.model_class.__name__
            interface_name = serializer_class.__name__.replace("Serializer", "")
            model_article = self._get_model_article(interface_name)

            idoc = INTERFACE_TPL % {
                "doc": serializer.__doc__,
                "model": interface_name,
            }
            idoc_create = CREATE_INTERFACE_TPL % {
                "article": model_article,
                "model": interface_name,
            }
            idoc_update = UPDATE_INTERFACE_TPL % {
                "article": model_article,
                "model": interface_name,
            }

            all_fields = serializer.get_fields()

            # Set pk field as the first field
            idoc += self._generate_readonly_prop(
                serializer.pk_field,
                self._get_field_type(all_fields[serializer.pk_field]),
                doc="Primary key",
            )

            main_fields = self._generate_props(serializer, mode="read")
            create_fields = self._generate_props(serializer, mode="create")
            update_fields = self._generate_props(serializer, mode="update")

            idoc += "".join(main_fields)
            idoc_create += "".join(create_fields)
            idoc_update += "".join(update_fields)

            idoc += "}\n"
            idoc_create += "}\n"
            idoc_update += "}\n"

            self.types_doc += idoc
            self.types_doc += "\n"
            self.types_doc += idoc_create
            self.types_doc += "\n"
            self.types_doc += idoc_update
            self.types_doc += "\n"

        directory = "/".join(filepath.split("/")[:-1])
        os.makedirs(directory, exist_ok=True)

        with open(filepath, "w+") as f:
            f.write(self.types_doc)
