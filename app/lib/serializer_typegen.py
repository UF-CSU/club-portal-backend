"""
Convert DRF Serializer to TypeScript Types.
"""

import os
import re
import typing
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from ipaddress import IPv4Address, IPv6Address
from typing import Literal, Optional, Type
from uuid import UUID

from django.db import models
from rest_framework import serializers

from core.abstracts.serializers import ModelSerializerBase, SerializerBase

DRF_FIELD_TO_TS_MAP = {
    serializers.IntegerField: "number",
    serializers.BooleanField: "boolean",
    serializers.CharField: "string",
    serializers.DateField: "string",
    serializers.DateTimeField: "string",
    serializers.DecimalField: "number",
    serializers.DurationField: "string",
    serializers.EmailField: "string",
    serializers.ModelField: "any",
    serializers.FileField: "string",
    serializers.FloatField: "number",
    serializers.ImageField: "string",
    serializers.SlugField: "any",
    serializers.TimeField: "string",
    serializers.URLField: "string",
    serializers.UUIDField: "string",
    serializers.IPAddressField: "string",
    serializers.FilePathField: "string",
    serializers.PrimaryKeyRelatedField: "number",
}

DJANGO_FIELD_TO_TS_MAP = {
    k: DRF_FIELD_TO_TS_MAP.get(v)
    for k, v in serializers.ModelSerializer.serializer_field_mapping.items()
}

PYTHON_TYPE_TO_TS_MAP = {
    str: "string",
    float: "number",
    bool: "boolean",
    bytes: "any",
    int: "number",
    UUID: "string",
    Decimal: "number",
    datetime: "string",
    date: "string",
    time: "string",
    timedelta: "string",
    IPv4Address: "string",
    IPv6Address: "string",
    dict: "any",
    typing.Any: "any",
    None: "unknown",
}

TAB = "    "

FILE_DOC_TPL = """/**
 * Club Portal Type Definitions
 *
 * Generated by club-portal-backend on %s.
 */
"""

INTERFACE_TPL = """
/**
 * %(doc)s
 */
declare interface I%(model)s {
"""

CREATE_INTERFACE_TPL = """
/**
 * Fields needed to create %(article)s %(model)s object.
 *
 * @see {@link I%(model)s}
 */
declare interface I%(model)sCreate {
"""

UPDATE_INTERFACE_TPL = """
/**
 * Fields that can be updated for %(article)s %(model)s object.
 *
 * @see {@link I%(model)s}
 */
declare interface I%(model)sUpdate {
"""

FIELD_TPL = TAB + "%(property)s: %(type)s;\n"
OPTIONAL_FIELD_TPL = TAB + "%(property)s?: %(type)s | null;\n"
READONLY_FIELD_TPL = TAB + "readonly %(property)s: %(type)s;\n"

FIELD_DOC_TPL = TAB + "/** %s */\n"

SEPARATOR_TPL = """/*
 * ===============================================================
 * %s
 * ===============================================================
 */"""

ENUM_TPL = "export enum %(name)s {\n"
ENUM_FIELD_TPL = TAB + "%(field)s = '%(value)s',\n"


class TypeGenerator:
    """Create TypeScript interfaces from a list of serializers."""

    def __init__(
        self,
        serializer_classes: list[Type[ModelSerializerBase]],
        readonly_serializer_classes: Optional[list[Type[ModelSerializerBase]]] = None,
    ):

        self.types_doc = ""
        self.serializer_classes = serializer_classes
        self.readonly_serializer_classes = readonly_serializer_classes
        self.enums: dict[str, dict[str, str]] = {}
        """Emuns to generate: enum_name => { value => label }"""

        self.types_file_name = "club-portal.d.ts"
        self.enums_file_name = "club-portal-enums.ts"

    @property
    def types_generated(self):
        return (len(self.serializer_classes) * 3) + len(
            self.readonly_serializer_classes
        )

    def _get_model_article(self, model_name: str):
        """Get a/an depending on a model's name."""

        return (
            "an"
            if model_name.lower().startswith(
                (
                    "a",
                    "e",
                    "i",
                    "o",
                )
            )
            else "a"
        )

    def _get_prop_type(
        self,
        field,
        is_list=False,
        using=DRF_FIELD_TO_TS_MAP,
    ):
        if not isinstance(field, type):
            field = type(field)

        field_type = using.get(field, None) or "any"

        if is_list:
            field_type += "[]"

        return field_type

    def _get_prop_type_from_field(
        self,
        field: serializers.Field,
        prop_name: str,
        is_list=False,
    ):
        """Get TS type for serializer field."""

        if isinstance(field, serializers.ChoiceField):
            return self._get_prop_choice_type(prop_name=prop_name, field=field)

        else:
            return self._get_prop_type(
                field, is_list=is_list, using=DRF_FIELD_TO_TS_MAP
            )

    def _get_prop_type_from_model(
        self,
        field_name,
        field: (
            serializers.ReadOnlyField
            | serializers.ManyRelatedField
            | serializers.SlugRelatedField
        ),
        serializer: SerializerBase,
        is_list=False,
    ):
        """Get the type for the field by going to the model."""

        model_field: models.Field | property = getattr(
            serializer.model_class, field.source or field_name
        )
        field_type = "any"

        if isinstance(field, serializers.ManyRelatedField):
            # Coerce type away from ManyToManyDescriptor
            model_field: models.ManyToManyField = (
                getattr(model_field, "field", None) or model_field
            )
            # Get actual field on serializer
            field = field.child_relation
            is_list = True

        if isinstance(field, serializers.ReadOnlyField):
            field_type_class = model_field.fget.__annotations__.get("return", "any")
            field_type = self._get_prop_type(
                field_type_class, is_list=is_list, using=PYTHON_TYPE_TO_TS_MAP
            )
        elif isinstance(field, serializers.SlugRelatedField):
            # getattr returns DeferredAttribute, which has a "field" attribute with actual field
            model_field = getattr(model_field.related_model, field.slug_field).field
            field_type = self._get_prop_type(
                model_field, is_list=is_list, using=DJANGO_FIELD_TO_TS_MAP
            )

        else:
            raise Exception(f"Invalid related field type: {type(field)}")

        return field_type

    def _get_prop_choice_type(self, prop_name: str, field: serializers.ChoiceField):
        """Returns either string literal union or enum."""

        if len(field.choices.keys()) > 20:
            # Return enum type
            enum_pre = prop_name.capitalize().replace("type", "").replace("_", "")
            enum_name = f"{enum_pre}Type"
            if enum_name not in self.enums.keys():
                self.enums[enum_name] = field.choices

            return f"import('./{self.enums_file_name}').{enum_name}"
        else:
            # Return string literal union type
            return " | ".join([f"'{key}'" for key in field.choices.keys()])

    def _get_indent(self, indent_level: int):
        return TAB * indent_level

    def _generate_prop(
        self,
        tpl: str,
        property: str,
        prop_type: str,
        doc: Optional[str] = None,
        indent_level=0,
    ):
        """Generate a TS field depending on tpl value."""

        generated = ""
        indent = self._get_indent(indent_level)

        if doc:
            generated += indent + FIELD_DOC_TPL % (doc,)

        generated += indent + tpl % {
            "property": property,
            "type": prop_type,
        }

        return generated

    def _props_factory(
        self,
        all_fields: dict[str | serializers.Field],
        ignore_nonnull: bool,
        force_optional: bool,
        indent_level=0,
    ):
        """Create function for generating props."""

        def gen_prop(
            prop_name, prop_type=None, required=True, readonly=False, **kwargs
        ):
            field = all_fields[prop_name]
            kwargs = {
                "property": prop_name,
                "prop_type": prop_type
                or self._get_prop_type_from_field(field, prop_name),
                "doc": kwargs.pop("doc", None) or getattr(field, "help_text", None),
                "indent_level": indent_level,
                **kwargs,
            }

            if (
                not readonly
                and not ignore_nonnull
                and not getattr(field, "allow_null", True)
            ):
                field_prop = self._generate_prop(FIELD_TPL, **kwargs)
            elif not readonly and (force_optional or not required):
                field_prop = self._generate_prop(OPTIONAL_FIELD_TPL, **kwargs)
            elif not readonly:
                field_prop = self._generate_prop(FIELD_TPL, **kwargs)
            else:
                field_prop = self._generate_prop(READONLY_FIELD_TPL, **kwargs)

            return field_prop

        return gen_prop

    def _generate_props(
        self,
        serializer: SerializerBase,
        mode: Literal["read", "create", "update"],
        indent_level=0,
    ) -> list[str]:
        """Generate a list of fields for given serializer."""

        all_fields = serializer.get_fields()
        properties = []
        indent = self._get_indent(indent_level)
        ignore_fields = []

        # Flags
        force_optional = False
        ignore_nonnull = False

        match mode:
            case "read":
                ignore_fields += serializer.writeonly_fields
            case "create":
                ignore_nonnull = True
                ignore_fields += serializer.readonly_fields
            case "update":
                ignore_nonnull = True
                force_optional = True
                ignore_fields += serializer.readonly_fields

        gen_prop = self._props_factory(
            all_fields,
            ignore_nonnull=ignore_nonnull,
            indent_level=indent_level,
            force_optional=force_optional,
        )

        # Set pk field as the first field
        if (
            getattr(serializer, "pk_field", None) is not None
            and serializer.pk_field not in ignore_fields
        ):
            # Only show pk as readonly if top level, and/or in read mode
            readonly = indent_level == 0 or indent_level > 0 and mode == "read"
            field_prop = gen_prop(
                serializer.pk_field, readonly=readonly, doc="Primary key"
            )
            properties.append(field_prop)
            ignore_fields.append(serializer.pk_field)  # No on else should handle it

        # Generate required fields
        for field_name in serializer.required_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field_prop = gen_prop(field_name, required=True)
            properties.append(field_prop)

        # Generate optional fields
        for field_name in serializer.optional_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field_prop = gen_prop(field_name, required=False)
            properties.append(field_prop)

        # Generate single value list fields
        for field_name in serializer.simple_list_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ManyRelatedField) and not isinstance(
                field.child_relation, serializers.SlugRelatedField
            ):
                field_type = self._get_prop_type(field.child_relation, is_list=True)
            elif isinstance(field, serializers.ManyRelatedField):
                field_type = self._get_prop_type_from_model(
                    field_name, field, serializer, is_list=True
                )
            elif getattr(field, "child", None) is not None:
                field_type = self._get_prop_type(field.child, is_list=True)
            else:
                field_type = "string[]"

            field_prop = gen_prop(
                field_name,
                prop_type=field_type,
                required=(field_name in serializer.required_fields),
            )
            properties.append(field_prop)

        # Generate nested fields
        for field_name in serializer.nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            nested_properties = self._generate_props(
                field,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + TAB + "%s: {\n" % (field_name,))
            else:
                properties.append(indent + TAB + "%s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + TAB + "}\n")

        # Generate nested list fields
        for field_name in serializer.many_nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]
            nested_properties = self._generate_props(
                field.child,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + TAB + "%s: {\n" % (field_name,))
            else:
                properties.append(indent + TAB + "%s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + TAB + "}[]\n")

        # Generate read only fields
        for field_name in serializer.readonly_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ReadOnlyField):
                # If the field is of type ReadOnly, then need to get the
                # type directly from the model (if possible)

                try:
                    field_type = self._get_prop_type_from_model(
                        field_name, field, serializer
                    )
                    field_prop = gen_prop(
                        field_name, prop_type=field_type, readonly=True
                    )
                except Exception as e:
                    field_type = "unknown"
                    field_prop = gen_prop(
                        field_name, prop_type=field_type, readonly=True
                    )
                    print(e)
            else:
                field_prop = gen_prop(field_name, readonly=True)

            properties.append(field_prop)

        return properties

    def _generate_interface(
        self,
        serializer_class: Type[ModelSerializerBase],
        mode: Literal["create", "read", "update"],
    ):
        """Create TS Interface from serializer."""

        serializer = serializer_class()
        interface_name = serializer_class.__name__.replace("Serializer", "")
        model_article = self._get_model_article(interface_name)
        idoc = ""

        match mode:
            case "read":
                idoc = INTERFACE_TPL % {
                    "doc": serializer.__doc__,
                    "model": interface_name,
                }
            case "create":
                idoc = CREATE_INTERFACE_TPL % {
                    "article": model_article,
                    "model": interface_name,
                }
            case "update":
                idoc = UPDATE_INTERFACE_TPL % {
                    "article": model_article,
                    "model": interface_name,
                }
            case _:
                raise Exception(f"Unknown mode: {mode}")

        properties = self._generate_props(serializer, mode=mode)

        idoc += "".join(properties)
        idoc += "}\n"

        return idoc

    def generate_docs(self, dirpath: str):
        """Convert serializers to typescript interfaces."""

        self.types_doc += FILE_DOC_TPL % datetime.now()

        for serializer_class in self.serializer_classes:
            idoc_read = self._generate_interface(serializer_class, mode="read")
            idoc_create = self._generate_interface(serializer_class, mode="create")
            idoc_update = self._generate_interface(serializer_class, mode="update")

            self.types_doc += idoc_read
            self.types_doc += "\n"
            self.types_doc += idoc_create
            self.types_doc += "\n"
            self.types_doc += idoc_update
            self.types_doc += "\n"

        if self.readonly_serializer_classes:
            self.types_doc += SEPARATOR_TPL % ("Read Only Types")

        for serializer_class in self.readonly_serializer_classes:

            idoc = self._generate_interface(serializer_class, mode="read")
            self.types_doc += idoc
            self.types_doc += "\n"

        self.enums_doc = ""
        for enum_name, enum_dict in self.enums.items():
            self.enums_doc += ENUM_TPL % {"name": enum_name}

            for value, label in enum_dict.items():
                field = label.replace(" ", "_").upper()
                field = re.sub(r"[^a-zA-Z0-9_]", "", field)
                # After replacements, some underscores get pushed together
                field = field.replace("__", "_")
                self.enums_doc += ENUM_FIELD_TPL % {
                    "field": field,
                    "value": value,
                }
            self.enums_doc += "}\n"
            self.enums_doc += "\n"

        os.makedirs(dirpath, exist_ok=True)

        types_filepath = dirpath + self.types_file_name

        with open(types_filepath, "w+") as f:
            f.write(self.types_doc)

        enum_filepath = dirpath + self.enums_file_name

        with open(enum_filepath, "w+") as f:
            f.write(self.enums_doc)

        index_filepath = dirpath + "index.ts"

        with open(index_filepath, "w+") as f:
            f.write(f"export * from './{self.enums_file_name}'")
