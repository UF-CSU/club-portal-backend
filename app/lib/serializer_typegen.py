"""
Convert DRF Serializer to TypeScript Types.
"""

import os
import re
import typing
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from ipaddress import IPv4Address, IPv6Address
from typing import Literal, Optional, Type
from uuid import UUID

from django.db import models
from pandas import show_versions
from rest_framework import serializers

from core.abstracts.serializers import ModelSerializerBase, SerializerBase

ReadSerializerType = Type[SerializerBase]
CreateSerializerType = Type[SerializerBase]
UpdateSerializerType = Type[SerializerBase]

InputSerializerType = (
    Type[SerializerBase]
    | tuple[ReadSerializerType, CreateSerializerType, UpdateSerializerType]
)

DRF_FIELD_TO_TS_MAP = {
    serializers.IntegerField: "number",
    serializers.BooleanField: "boolean",
    serializers.CharField: "string",
    serializers.DateField: "Date",
    serializers.DateTimeField: "Date",
    serializers.DecimalField: "number",
    serializers.DurationField: "string",
    serializers.EmailField: "string",
    serializers.ModelField: "any",
    serializers.FileField: "string",
    serializers.FloatField: "number",
    serializers.ImageField: "string",
    serializers.SlugField: "any",
    serializers.TimeField: "string",
    serializers.URLField: "string",
    serializers.UUIDField: "string",
    serializers.IPAddressField: "string",
    serializers.FilePathField: "string",
    serializers.PrimaryKeyRelatedField: "number",
    serializers.ListField: "any",
}

DJANGO_FIELD_TO_TS_MAP = {
    k: DRF_FIELD_TO_TS_MAP.get(v)
    for k, v in serializers.ModelSerializer.serializer_field_mapping.items()
}

PYTHON_TYPE_TO_TS_MAP = {
    str: "string",
    float: "number",
    bool: "boolean",
    bytes: "any",
    int: "number",
    UUID: "string",
    Decimal: "number",
    datetime: "Date",
    date: "Date",
    time: "Date",
    timedelta: "string",
    IPv4Address: "string",
    IPv6Address: "string",
    dict: "any",
    typing.Any: "any",
    None: "unknown",
}

TAB = "    "

FILE_DOC_TPL = """/**
 * Club Portal Type Definitions
 *
 * Generated by club-portal-backend on %s.
 */
"""

INTERFACE_NAME_TPL = "I%s"
CREATE_INTERFACE_NAME_TPL = "I%sCreate"
UPDATE_INTERFACE_NAME_TPL = "I%sUpdate"

INTERFACE_TPL = """
/**
 * %(doc)s
 */
declare interface %(name)s {
"""

CREATE_INTERFACE_TPL = """
/**
 * Fields needed to create %(article)s %(name)s object.
 *
 * @see {@link %(read_name)s}
 */
declare interface %(name)s {
"""

UPDATE_INTERFACE_TPL = """
/**
 * Fields that can be updated for %(article)s %(name)s object.
 *
 * @see {@link %(read_name)s}
 */
declare interface %(name)s {
"""

FIELD_TPL = TAB + "%(property)s: %(type)s;\n"
OPTIONAL_FIELD_TPL = TAB + "%(property)s?: %(type)s | null;\n"
READONLY_FIELD_TPL = TAB + "readonly %(property)s: %(type)s;\n"
READONLY_OPTIONAL_FIELD_TPL = TAB + "readonly %(property)s?: %(type)s | null;\n"

FIELD_DOC_TPL = TAB + "/** %s */\n"

SEPARATOR_TPL = """/*
 * ===============================================================
 * MARK: %s
 * ===============================================================
 */"""

ENUM_TPL = "export enum %(name)s {\n"
ENUM_FIELD_TPL = TAB + "%(field)s = %(value)s,\n"


class TypeGenerator:
    """
    Create TypeScript interfaces from a list of serializers.

    Field conventions:
    - `allow_null`: If null values are allowed in the database. Use `serializer.nullable_fields` to access.
    - `required`: If setting this field is required on creation. Use `serialzier.required_fields` to access.
    """

    def __init__(
        self,
        serializer_classes: list[InputSerializerType],
        readonly_serializer_classes: Optional[list[InputSerializerType]] = None,
    ):

        self.types_doc = ""
        self.serializer_classes = serializer_classes
        self.readonly_serializer_classes = readonly_serializer_classes
        self.enums: dict[str, dict[str, str]] = {}
        """Emuns to generate: enum_name => { value => label }"""

        self.types_file_name = "club-portal.d.ts"
        self.enums_file_name = "club-portal-enums.ts"

        self.serializer_interfaces_map = {}
        self.other_interfaces = []

    @property
    def types_generated(self):
        return (len(self.serializer_classes) * 3) + len(
            self.readonly_serializer_classes
        )

    def _get_model_article(self, model_name: str):
        """Get a/an depending on a model's name."""

        return (
            "an"
            if model_name.lower().startswith(
                (
                    "a",
                    "e",
                    "i",
                    "o",
                )
            )
            else "a"
        )

    def _get_prop_type(self, field, is_list=False, using=DRF_FIELD_TO_TS_MAP, **kwargs):
        if not isinstance(field, type):
            field = type(field)

        field_type = using.get(field, None) or "any"

        if is_list:
            field_type += "[]"

        return field_type

    def _get_prop_type_from_field(
        self,
        field: serializers.Field,
        prop_name: str,
        serializer: SerializerBase,
        is_list=False,
    ):
        """Get TS type for serializer field."""

        if isinstance(field, serializers.ChoiceField):
            return self._get_prop_choice_type(prop_name=prop_name, field=field)
        elif isinstance(field, serializers.SlugRelatedField):
            return self._get_prop_type_from_model(
                prop_name, field=field, serializer=serializer, is_list=is_list
            )

        else:
            return self._get_prop_type(
                field, prop_name=prop_name, is_list=is_list, using=DRF_FIELD_TO_TS_MAP
            )

    def _get_prop_type_from_model(
        self,
        field_name,
        field: (
            serializers.ReadOnlyField
            | serializers.ManyRelatedField
            | serializers.SlugRelatedField
            # | serializers.ListField
        ),
        serializer: SerializerBase,
        is_list=False,
    ):
        """Get the type for the field by going to the model."""

        model_field: models.Field | property = getattr(
            serializer.model_class, field.source or field_name
        )
        field_type = "any"

        if isinstance(field, serializers.ManyRelatedField):
            # Coerce type away from ManyToManyDescriptor
            model_field: models.ManyToManyField = (
                getattr(model_field, "field", None) or model_field
            )
            # Get actual field on serializer
            field = field.child_relation
            is_list = True

        if isinstance(field, serializers.ReadOnlyField):
            # FIXME: Raises error if cached_property
            field_type_class = model_field.fget.__annotations__.get("return", "any")
            field_type = self._get_prop_type(
                field_type_class,
                prop_name=field_name,
                is_list=is_list,
                using=PYTHON_TYPE_TO_TS_MAP,
            )
        elif isinstance(field, serializers.SlugRelatedField):
            # getattr returns DeferredAttribute, which has a "field" attribute with actual field
            if hasattr(model_field, "related_model"):
                model_field = getattr(model_field.related_model, field.slug_field).field
            elif hasattr(model_field.field, "related_model"):
                # model_field is a ForwardManyToOneDescriptor
                model_field = getattr(
                    model_field.field.related_model, field.slug_field
                ).field

            field_type = self._get_prop_type(
                model_field,
                prop_name=field_name,
                is_list=is_list,
                using=DJANGO_FIELD_TO_TS_MAP,
            )

        else:
            raise Exception(f"Invalid related field type: {type(field)}")

        return field_type

    def _get_prop_choice_type(
        self, prop_name: str, field: serializers.ChoiceField, is_list=False
    ):
        """Returns either string literal union or enum."""

        # Check if type should be string literal or enum
        compare_key = list(field.choices.keys())[0]
        is_enum = len(field.choices.keys()) > 20 or str(compare_key).lower() != str(
            field.choices.get(compare_key)
        ).lower().replace(" ", "_")

        # Generate the type
        if is_enum:
            # Return enum type
            enum_pre = prop_name.capitalize().replace("type", "").replace("_", "")
            enum_name = f"{enum_pre}Type"
            if enum_name not in self.enums.keys():
                self.enums[enum_name] = field.choices

            prop_type = f"import('./{self.enums_file_name}').{enum_name}"

            if is_list:
                prop_type += "[]"
        else:
            # Return string literal union type
            prop_type = " | ".join([f"'{key}'" for key in field.choices.keys()])

            if is_list:
                prop_type = f"({prop_type})[]"

        return prop_type

    def _get_indent(self, indent_level: int):
        return TAB * indent_level

    def _generate_prop(
        self,
        tpl: str,
        property: str,
        prop_type: str,
        doc: Optional[str] = None,
        indent_level=0,
    ):
        """Generate a TS field depending on tpl value."""

        generated = ""
        indent = self._get_indent(indent_level)

        if doc:
            generated += indent + FIELD_DOC_TPL % (doc,)

        generated += indent + tpl % {
            "property": property,
            "type": prop_type,
        }

        return generated

    def _props_factory(
        self,
        # all_fields: dict[str | serializers.Field],
        serializer: SerializerBase,
        ignore_nonnull: bool,
        force_optional: bool,
        indent_level=0,
    ):
        """Create function for generating props."""
        all_fields = serializer.get_fields()

        def gen_prop(
            prop_name, prop_type=None, required=True, readonly=False, **kwargs
        ):
            field = all_fields[prop_name]

            show_nullable = not ignore_nonnull and getattr(field, "allow_null", True)
            show_optional = force_optional or (not required and show_nullable)

            kwargs = {
                "property": prop_name,
                "prop_type": prop_type
                or self._get_prop_type_from_field(
                    field, prop_name, serializer=serializer
                ),
                "doc": kwargs.pop("doc", None) or getattr(field, "help_text", None),
                "indent_level": indent_level,
                **kwargs,
            }

            if (
                not readonly
                and not ignore_nonnull
                and not getattr(field, "allow_null", True)
                and not show_optional
            ):
                field_prop = self._generate_prop(FIELD_TPL, **kwargs)
            elif not readonly and show_versions:
                field_prop = self._generate_prop(OPTIONAL_FIELD_TPL, **kwargs)
            elif not readonly:
                field_prop = self._generate_prop(FIELD_TPL, **kwargs)
            elif readonly and show_optional:
                field_prop = self._generate_prop(READONLY_OPTIONAL_FIELD_TPL, **kwargs)
            else:
                field_prop = self._generate_prop(READONLY_FIELD_TPL, **kwargs)

            return field_prop

        return gen_prop

    def _generate_props(
        self,
        serializer: SerializerBase,
        mode: Literal["read", "create", "update"],
        indent_level=0,
    ) -> list[str]:
        """Generate a list of fields for given serializer."""

        all_fields = serializer.get_fields()
        properties = []
        indent = self._get_indent(indent_level)
        ignore_fields = []

        # Flags
        force_optional = False
        ignore_nonnull = False
        """If a field is `allow_null=False`, ignore that because there may be a default."""
        # nested = False

        match mode:
            case "read":
                ignore_fields += serializer.writeonly_fields
            case "create":
                ignore_nonnull = True
                ignore_fields += serializer.readonly_fields
            case "update":
                ignore_nonnull = True
                force_optional = True
                ignore_fields += [
                    field
                    for field in serializer.readonly_fields
                    if (field != getattr(serializer, "pk_field", None))
                ]

        gen_prop = self._props_factory(
            # all_fields,
            serializer=serializer,
            ignore_nonnull=ignore_nonnull,
            indent_level=indent_level,
            force_optional=force_optional,
        )

        # Set pk field as the first field
        if (
            getattr(serializer, "pk_field", None) is not None
            and serializer.pk_field not in ignore_fields
        ):
            # Only show pk as readonly if top level, and/or in read mode
            readonly = indent_level == 0 or indent_level > 0 and mode == "read"
            required = mode != "create"
            field_prop = gen_prop(
                serializer.pk_field,
                readonly=readonly,
                doc="Primary key",
                required=required,
            )
            properties.append(field_prop)
            ignore_fields.append(serializer.pk_field)  # No on else should handle it

        simple_fields = [
            field for field in serializer.simple_fields if field not in ignore_fields
        ]

        # Generate required fields
        for field_name in serializer.required_fields:
            if field_name not in simple_fields:
                continue

            field_prop = gen_prop(field_name, required=True)
            properties.append(field_prop)

        # Generate optional fields
        for field_name in serializer.optional_fields:
            if field_name not in simple_fields:
                continue

            field_prop = gen_prop(field_name, required=False)
            properties.append(field_prop)

        # Generate single value list fields
        for field_name in serializer.simple_list_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ManyRelatedField) and not isinstance(
                field.child_relation, serializers.SlugRelatedField
            ):
                field_type = self._get_prop_type(
                    field.child_relation, prop_name=field_name, is_list=True
                )
            elif isinstance(field, serializers.ManyRelatedField):
                field_type = self._get_prop_type_from_model(
                    field_name, field, serializer, is_list=True
                )
            elif getattr(field, "child", None) is not None:
                if isinstance(field.child, serializers.ChoiceField):
                    field_type = self._get_prop_choice_type(
                        field_name, field.child, is_list=True
                    )
                else:
                    field_type = self._get_prop_type(
                        field.child, prop_name=field_name, is_list=True
                    )
            else:
                field_type = "string[]"

            field_prop = gen_prop(
                field_name,
                prop_type=field_type,
                required=(field_name in serializer.required_fields),
            )
            properties.append(field_prop)

        # Generate nested fields
        for field_name in serializer.nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            if mode == "read":
                is_required = not field.allow_null and not force_optional
            else:
                is_required = field.required and not force_optional

            if isinstance(field, serializers.BaseSerializer) and type(field) in [
                *self.serializer_classes,
                *self.readonly_serializer_classes,
            ]:
                serializer_field = type(field)

                if field not in self.serializer_interfaces_map.keys():
                    nested_mode = (
                        mode
                        if type(field) not in self.readonly_serializer_classes
                        else "read"
                    )
                    doc = self._generate_interface(serializer_field, mode=nested_mode)
                    self.other_interfaces.append(doc)
                else:
                    nested_mode = mode

                field_type = self.serializer_interfaces_map[
                    f"{serializer_field}_{nested_mode}"
                ]

                field_prop = gen_prop(
                    field_name,
                    prop_type=field_type,
                    required=is_required,
                )
                properties.append(field_prop)

                continue

            nested_properties = self._generate_props(
                field,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if is_required:
                properties.append(indent + TAB + "%s: {\n" % (field_name,))
                properties += nested_properties
                properties.append(indent + TAB + "}\n")
            else:
                properties.append(indent + TAB + "%s?: {\n" % (field_name,))
                properties += nested_properties
                properties.append(indent + TAB + "} | null\n")

        # Generate nested list fields
        for field_name in serializer.many_nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name].child

            if isinstance(field, serializers.BaseSerializer) and type(field) in [
                *self.serializer_classes,
                *self.readonly_serializer_classes,
            ]:
                serializer_field = type(field)

                if f"{field}_{mode}" not in self.serializer_interfaces_map.keys():
                    nested_mode = (
                        mode
                        if type(field) not in self.readonly_serializer_classes
                        else "read"
                    )
                    doc = self._generate_interface(serializer_field, mode=nested_mode)
                    self.other_interfaces.append(doc)

                field_type = self.serializer_interfaces_map[
                    f"{serializer_field}_{nested_mode}"
                ]
                field_prop = gen_prop(
                    field_name,
                    prop_type=field_type + "[]",
                    required=(field_name in serializer.required_fields),
                )
                properties.append(field_prop)

                continue

            nested_properties = self._generate_props(
                field, mode=mode, indent_level=indent_level + 1
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + TAB + "%s: {\n" % (field_name,))
            else:
                properties.append(indent + TAB + "%s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + TAB + "}[]\n")

        # Generate read only fields
        for field_name in serializer.readonly_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ReadOnlyField):
                # If the field is of type ReadOnly, then need to get the
                # type directly from the model (if possible)

                try:
                    field_type = self._get_prop_type_from_model(
                        field_name, field, serializer
                    )
                    field_prop = gen_prop(
                        field_name,
                        prop_type=field_type,
                        readonly=True,
                        required=(field_name not in serializer.nullable_fields),
                    )
                except Exception as e:
                    field_type = "unknown"
                    field_prop = gen_prop(
                        field_name, prop_type=field_type, readonly=True
                    )
                    print(e)
            else:
                field_prop = gen_prop(
                    field_name,
                    readonly=True,
                    required=(field_name not in serializer.nullable_fields),
                )

            properties.append(field_prop)

        return properties

    def _generate_interface(
        self,
        serializer_class: Type[ModelSerializerBase],
        mode: Literal["create", "read", "update"],
    ):
        """Create TS Interface from serializer."""

        serializer = serializer_class()
        model_name = serializer_class.__name__.replace("Serializer", "")

        match mode:
            case "create":
                model_name = model_name.replace("Create", "")
            case "update":
                model_name = model_name.replace("Update", "")

        interface_name = None
        idoc = ""
        read_interface_name = interface_name = INTERFACE_NAME_TPL % (model_name)

        match mode:
            case "read":
                model_article = self._get_model_article(read_interface_name)

                idoc = INTERFACE_TPL % {
                    "doc": serializer.__doc__,
                    "name": read_interface_name,
                }
            case "create":
                interface_name = CREATE_INTERFACE_NAME_TPL % (model_name)
                model_article = self._get_model_article(interface_name)

                idoc = CREATE_INTERFACE_TPL % {
                    "article": model_article,
                    "name": interface_name,
                    "read_name": read_interface_name,
                }
            case "update":
                interface_name = UPDATE_INTERFACE_NAME_TPL % (model_name)
                model_article = self._get_model_article(interface_name)

                idoc = UPDATE_INTERFACE_TPL % {
                    "article": model_article,
                    "name": interface_name,
                    "read_name": read_interface_name,
                }
            case _:
                raise Exception(f"Unknown mode: {mode}")

        self.serializer_interfaces_map[f"{serializer_class}_{mode}"] = interface_name

        properties = self._generate_props(serializer, mode=mode)

        idoc += "\n".join(properties)
        idoc += "}\n"

        return idoc

    def _generate_enum(self, name: str, values_dict: dict):
        """Create TS enums."""
        doc = ""

        doc += ENUM_TPL % {"name": name}

        for value, label in values_dict.items():
            field = label.replace(" ", "_").upper()
            field = re.sub(r"[^a-zA-Z0-9_]", "", field)
            # After replacements, some underscores get pushed together
            field = field.replace("__", "_")

            if not str(value).isnumeric():
                value = f"'{value}'"

            doc += ENUM_FIELD_TPL % {
                "field": field,
                "value": value,
            }
        doc += "}\n"
        doc += "\n"

        return doc

    def generate_docs(self, dirpath: str, write_types=True):
        """Convert serializers to typescript interfaces."""

        self.types_doc += FILE_DOC_TPL % datetime.now()

        for serializer_class in self.serializer_classes:
            if isinstance(serializer_class, tuple):
                read_s, create_s, update_s = serializer_class
                idoc_read = self._generate_interface(read_s, mode="read")
                idoc_create = self._generate_interface(create_s, mode="create")
                idoc_update = self._generate_interface(update_s, mode="update")
            else:
                idoc_read = self._generate_interface(serializer_class, mode="read")
                idoc_create = self._generate_interface(serializer_class, mode="create")
                idoc_update = self._generate_interface(serializer_class, mode="update")

            self.types_doc += idoc_read
            self.types_doc += "\n"
            self.types_doc += idoc_create
            self.types_doc += "\n"
            self.types_doc += idoc_update
            self.types_doc += "\n"

        if self.readonly_serializer_classes:
            self.types_doc += SEPARATOR_TPL % ("Read Only Types")

        for serializer_class in self.readonly_serializer_classes:

            idoc = self._generate_interface(serializer_class, mode="read")
            self.types_doc += idoc
            self.types_doc += "\n"

        self.enums_doc = ""
        for enum_name, enum_dict in self.enums.items():
            self.enums_doc += self._generate_enum(enum_name, enum_dict)

        if not write_types:
            print("Type checking mode only, skipping writing files.")
            return

        os.makedirs(dirpath, exist_ok=True)

        types_filepath = dirpath + self.types_file_name

        with open(types_filepath, "w+") as f:
            f.write(self.types_doc)

        enum_filepath = dirpath + self.enums_file_name

        with open(enum_filepath, "w+") as f:
            f.write(self.enums_doc)

        index_filepath = dirpath + "index.ts"

        with open(index_filepath, "w+") as f:
            f.write(f"export * from './{self.enums_file_name}'")
