"""
Convert DRF Serializer to TypeScript Types.
"""

import os
import typing
from datetime import date, datetime, time, timedelta
from decimal import Decimal
from ipaddress import IPv4Address, IPv6Address
from typing import Literal, Optional, Type
from uuid import UUID

from django.db import models
from rest_framework import serializers

from core.abstracts.serializers import ModelSerializerBase, SerializerBase

DRF_FIELD_TO_TS_MAP = {
    serializers.IntegerField: "number",
    serializers.BooleanField: "boolean",
    serializers.CharField: "string",
    serializers.DateField: "string",
    serializers.DateTimeField: "string",
    serializers.DecimalField: "number",
    serializers.DurationField: "string",
    serializers.EmailField: "string",
    serializers.ModelField: "any",
    serializers.FileField: "string",
    serializers.FloatField: "number",
    serializers.ImageField: "string",
    serializers.SlugField: "any",
    serializers.TimeField: "string",
    serializers.URLField: "string",
    serializers.UUIDField: "string",
    serializers.IPAddressField: "string",
    serializers.FilePathField: "string",
    serializers.PrimaryKeyRelatedField: "number",
}

DJANGO_FIELD_TO_TS_MAP = {
    k: DRF_FIELD_TO_TS_MAP.get(v)
    for k, v in serializers.ModelSerializer.serializer_field_mapping.items()
}

PYTHON_TYPE_TO_TS_MAP = {
    str: "string",
    float: "number",
    bool: "boolean",
    bytes: "any",
    int: "number",
    UUID: "string",
    Decimal: "number",
    datetime: "string",
    date: "string",
    time: "string",
    timedelta: "string",
    IPv4Address: "string",
    IPv6Address: "string",
    dict: "any",
    typing.Any: "any",
    None: "unknown",
}

FILE_DOC_TPL = """/**
 * Club Portal Type Definitions
 * Generated by club-portal-backend on %s.
 */
"""

INTERFACE_TPL = """
/**
 * %(doc)s
 */
declare interface I%(model)s {
"""

CREATE_INTERFACE_TPL = """
/**
 * Fields needed to create %(article)s %(model)s object.
 *
 * @see {@link I%(model)s}
 */
declare interface I%(model)sCreate {
"""

UPDATE_INTERFACE_TPL = """
/**
 * Fields that can be updated for %(article)s %(model)s object.
 *
 * @see {@link I%(model)s}
 */
declare interface I%(model)sUpdate {
"""

FIELD_TPL = "  %(property)s: %(type)s;\n"
OPTIONAL_FIELD_TPL = "  %(property)s?: %(type)s;\n"
READONLY_FIELD_TPL = "  readonly %(property)s: %(type)s;\n"

FIELD_DOC_TPL = "  /** %s */\n"


class TypeGenerator:
    """Create TypeScript interfaces from a list of serializers."""

    def __init__(self, serializer_classes: list[Type[ModelSerializerBase]]):

        self.types_doc = ""
        self.serializer_classes = serializer_classes

    def _get_model_article(self, model_name: str):
        """Get a/an depending on a model's name."""

        return (
            "an"
            if model_name.lower().startswith(
                (
                    "a",
                    "e",
                    "i",
                    "o",
                )
            )
            else "a"
        )

    def _get_field_type(self, field, is_list=False, using=DRF_FIELD_TO_TS_MAP):
        """Return TS type for given field."""

        if not isinstance(field, type):
            field = type(field)

        field_type = using.get(field, None) or "any"

        if is_list:
            field_type += "[]"

        return field_type

    def _get_field_type_from_model(
        self,
        field_name,
        field: (
            serializers.ReadOnlyField
            | serializers.ManyRelatedField
            | serializers.SlugRelatedField
        ),
        serializer: SerializerBase,
        is_list=False,
    ):
        """Get the type for the field by going to the model."""

        model_field: models.Field | property = getattr(
            serializer.model_class, field.source or field_name
        )
        field_type = "any"

        if isinstance(field, serializers.ManyRelatedField):
            # Coerce type away from ManyToManyDescriptor
            model_field: models.ManyToManyField = (
                getattr(model_field, "field", None) or model_field
            )
            # Get actual field on serializer
            field = field.child_relation
            is_list = True

        if isinstance(field, serializers.ReadOnlyField):
            field_type_class = model_field.fget.__annotations__.get("return", "any")
            field_type = self._get_field_type(
                field_type_class, is_list=is_list, using=PYTHON_TYPE_TO_TS_MAP
            )
        elif isinstance(field, serializers.SlugRelatedField):
            # getattr returns DeferredAttribute, which has a "field" attribute with actual field
            model_field = getattr(model_field.related_model, field.slug_field).field
            field_type = self._get_field_type(
                model_field, is_list=is_list, using=DJANGO_FIELD_TO_TS_MAP
            )

        else:
            raise Exception(f"Invalid related field type: {type(field)}")

        return field_type

    def _get_indent(self, indent_level: int):
        return "  " * indent_level

    def _generate_prop(
        self,
        tpl: str,
        property: str,
        prop_type: str,
        doc: Optional[str] = None,
        indent_level=0,
    ):
        """Generate a TS field depending on tpl value."""

        generated = ""
        indent = self._get_indent(indent_level)

        if doc:
            generated += indent + FIELD_DOC_TPL % (doc,)

        generated += indent + tpl % {
            "property": property,
            "type": prop_type,
        }

        return generated

    def _generate_required_prop(self, property: str, prop_type: str, **kwargs):
        """Generate a required TS field."""
        return self._generate_prop(FIELD_TPL, property, prop_type, **kwargs)

    def _generate_optional_prop(self, property: str, prop_type: str, **kwargs):
        """Generate a optional TS field."""
        return self._generate_prop(OPTIONAL_FIELD_TPL, property, prop_type, **kwargs)

    def _generate_readonly_prop(self, property: str, prop_type: str, **kwargs):
        """Generate a readonly TS field."""
        return self._generate_prop(READONLY_FIELD_TPL, property, prop_type, **kwargs)

    def _props_factory(
        self,
        all_fields: dict[str | serializers.Field],
        ignore_nonnull: bool,
        force_optional: bool,
        indent_level=0,
    ):
        """Create function for generating props."""

        def gen_prop(
            prop_name, prop_type=None, required=True, readonly=False, **kwargs
        ):
            field = all_fields[prop_name]
            kwargs = {
                "property": prop_name,
                "prop_type": prop_type or self._get_field_type(field),
                "doc": kwargs.pop("doc", None) or getattr(field, "help_text", None),
                "indent_level": indent_level,
                **kwargs,
            }

            if (
                not readonly
                and not ignore_nonnull
                and not getattr(field, "allow_null", True)
            ):
                field_prop = self._generate_required_prop(**kwargs)
            elif not readonly and (force_optional or not required):
                field_prop = self._generate_optional_prop(**kwargs)
            elif not readonly:
                field_prop = self._generate_required_prop(**kwargs)
            else:
                field_prop = self._generate_readonly_prop(**kwargs)

            return field_prop

        return gen_prop

    def _generate_props(
        self,
        serializer: SerializerBase,
        mode: Literal["read", "create", "update"],
        indent_level=0,
    ):
        """Generate a list of fields for given serializer."""

        all_fields = serializer.get_fields()
        properties = []
        indent = self._get_indent(indent_level)
        ignore_fields = []

        # Flags
        force_optional = False
        ignore_nonnull = False

        match mode:
            case "read":
                ignore_fields += serializer.writeonly_fields
            case "create":
                ignore_nonnull = True
                ignore_fields += serializer.readonly_fields
            case "update":
                ignore_nonnull = True
                force_optional = True
                ignore_fields += serializer.readonly_fields

        gen_prop = self._props_factory(
            all_fields,
            ignore_nonnull=ignore_nonnull,
            indent_level=indent_level,
            force_optional=force_optional,
        )

        # Set pk field as the first field
        if (
            getattr(serializer, "pk_field", None) is not None
            and serializer.pk_field not in ignore_fields
        ):
            # Only show pk as readonly if top level, and/or in read mode
            readonly = indent_level == 0 or indent_level > 0 and mode == "read"
            field_prop = gen_prop(
                serializer.pk_field, readonly=readonly, doc="Primary key"
            )
            properties.append(field_prop)
            ignore_fields.append(serializer.pk_field)  # No on else should handle it

        # Generate required fields
        for field_name in serializer.required_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field_prop = gen_prop(field_name, required=True)
            properties.append(field_prop)

        # Generate optional fields
        for field_name in serializer.optional_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field_prop = gen_prop(field_name, required=False)
            properties.append(field_prop)

        # Generate single value list fields
        for field_name in serializer.simple_list_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ManyRelatedField) and not isinstance(
                field.child_relation, serializers.SlugRelatedField
            ):
                field_type = self._get_field_type(field.child_relation, is_list=True)
            elif isinstance(field, serializers.ManyRelatedField):
                field_type = self._get_field_type_from_model(
                    field_name, field, serializer, is_list=True
                )
            elif getattr(field, "child", None) is not None:
                field_type = self._get_field_type(field.child, is_list=True)
            else:
                field_type = "string[]"

            field_prop = gen_prop(
                field_name,
                prop_type=field_type,
                required=(field_name in serializer.required_fields),
            )
            properties.append(field_prop)

        # Generate nested fields
        for field_name in serializer.nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]

            nested_properties = self._generate_props(
                field,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + "  %s: {\n" % (field_name,))
            else:
                properties.append(indent + "  %s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + "  }\n")

        # Generate nested list fields
        for field_name in serializer.many_nested_fields:
            if field_name in ignore_fields:
                continue

            field = all_fields[field_name]
            nested_properties = self._generate_props(
                field.child,
                mode=mode,
                indent_level=indent_level + 1,
            )

            # Skip fields with no properties
            if len(nested_properties) < 1:
                continue

            if field_name in serializer.required_fields and not force_optional:
                properties.append(indent + "  %s: {\n" % (field_name,))
            else:
                properties.append(indent + "  %s?: {\n" % (field_name,))

            properties += nested_properties
            properties.append(indent + "  }[]\n")

        # Generate read only fields
        for field_name in serializer.readonly_fields:
            if (
                field_name not in serializer.simple_fields
                or field_name in ignore_fields
            ):
                continue

            field = all_fields[field_name]

            if isinstance(field, serializers.ReadOnlyField):
                # If the field is of type ReadOnly, then need to get the
                # type directly from the model (if possible)

                try:
                    field_type = self._get_field_type_from_model(
                        field_name, field, serializer
                    )
                    field_prop = gen_prop(
                        field_name, prop_type=field_type, readonly=True
                    )
                except Exception as e:
                    field_type = "unknown"
                    field_prop = gen_prop(field_name, readonly=True)
                    print(e)
            else:
                field_prop = gen_prop(field_name, readonly=True)

            properties.append(field_prop)

        return properties

    def generate_docs(self, filepath: str):
        """Convert serializers to typescript interfaces."""

        self.types_doc += FILE_DOC_TPL % datetime.now()

        for serializer_class in self.serializer_classes:
            serializer = serializer_class()
            # interface_name = serializer.model_class.__name__
            interface_name = serializer_class.__name__.replace("Serializer", "")
            model_article = self._get_model_article(interface_name)

            idoc = INTERFACE_TPL % {
                "doc": serializer.__doc__,
                "model": interface_name,
            }
            idoc_create = CREATE_INTERFACE_TPL % {
                "article": model_article,
                "model": interface_name,
            }
            idoc_update = UPDATE_INTERFACE_TPL % {
                "article": model_article,
                "model": interface_name,
            }

            # all_fields = serializer.get_fields()

            main_fields = self._generate_props(serializer, mode="read")
            create_fields = self._generate_props(serializer, mode="create")
            update_fields = self._generate_props(serializer, mode="update")

            idoc += "".join(main_fields)
            idoc_create += "".join(create_fields)
            idoc_update += "".join(update_fields)

            idoc += "}\n"
            idoc_create += "}\n"
            idoc_update += "}\n"

            self.types_doc += idoc
            self.types_doc += "\n"
            self.types_doc += idoc_create
            self.types_doc += "\n"
            self.types_doc += idoc_update
            self.types_doc += "\n"

        directory = "/".join(filepath.split("/")[:-1])
        os.makedirs(directory, exist_ok=True)

        with open(filepath, "w+") as f:
            f.write(self.types_doc)
